// Generated by CoffeeScript 1.9.2
(function() {
  var ChildProcess, ShellEnvironment;

  ChildProcess = require('child_process');

  ShellEnvironment = (function() {
    function ShellEnvironment(options) {
      if ((options != null) && (options.cachePeriod != null)) {
        this.cachePeriod = options.cachePeriod;
      } else {
        this.cachePeriod = 1;
      }
      if ((options != null) && (options.command != null)) {
        this.command = options.command;
      } else {
        this.command = 'env';
      }
    }

    ShellEnvironment.prototype.isCacheValid = function() {
      return (this.environmentCache != null) && (this.environmentCacheDate != null) && (new Date() - this.environmentCacheDate) < this.cachePeriod;
    };

    ShellEnvironment.prototype.setCachedEnvironment = function(environment) {
      if (environment && this.cachePeriod) {
        this.environmentCache = environment;
        return this.environmentCacheDate = new Date();
      }
    };

    ShellEnvironment.prototype.getEnvironment = function(callback) {
      if (this.isCacheValid()) {
        callback(null, this.environmentCache);
      } else {
        this.getBestEnvironment((function(_this) {
          return function(error, environment) {
            _this.setCachedEnvironment(environment);
            return callback(error, environment);
          };
        })(this));
      }
      return void 0;
    };

    ShellEnvironment.prototype.getBestEnvironment = function(callback) {
      return this.getLoginEnvironmentFromShell(function(error, environment) {
        if (environment) {
          return callback(null, environment);
        } else {
          console.warn("ShellEnvironment: " + error);
          return callback(error, process.env);
        }
      });
    };

    ShellEnvironment.prototype.getLoginEnvironmentFromShell = function(callback) {
      var child, outputBuffer;
      child = ChildProcess.spawn(process.env.SHELL, ['-ilc', this.command + ">&3"], {
        detached: true,
        stdio: ['ignore', 'ignore', process.stderr, 'pipe']
      });
      outputBuffer = '';
      child.stdio[3].on('data', function(data) {
        return outputBuffer += data;
      });
      child.on('close', function(code, signal) {
        var definition, environment, i, key, len, ref, ref1, value;
        if (code !== 0) {
          return callback("child process exited with non-zero status " + code);
        } else {
          environment = {};
          ref = outputBuffer.split('\n');
          for (i = 0, len = ref.length; i < len; i++) {
            definition = ref[i];
            ref1 = definition.trim().split('=', 2), key = ref1[0], value = ref1[1];
            if (key !== '') {
              environment[key] = value;
            }
          }
          return callback(null, environment);
        }
      });
      return child.on('error', function(error) {
        console.log('error', error);
        return callback("child process failed with " + error);
      });
    };

    ShellEnvironment.loginEnvironment = function(callback) {
      this.shellEnvironment || (this.shellEnvironment = new ShellEnvironment());
      return this.shellEnvironment.getEnvironment(callback);
    };

    return ShellEnvironment;

  })();

  module.exports = ShellEnvironment;

}).call(this);
